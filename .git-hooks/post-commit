#!/bin/bash

# Environment variables
GIT_USER_1_NAME_VALUE=${GIT_USER_1_NAME:-""}
GCP_CF_ENDPOINT_VALUE=${GCP_CF_ENDPOINT:-""}

# Function to URL-encode a string
urlencode() {
    local string="${1}"
    local encoded=""
    local length="${#string}"
    for (( i = 0; i < length; i++ )); do
        local c="${string:i:1}"
        case "${c}" in
            [a-zA-Z0-9.~_-]) encoded+="${c}" ;;
            *) encoded+=$(printf '%%%02X' "'${c}") ;;
        esac
    done
    echo "${encoded}"
}

repo_url=$(git remote get-url origin)

# Split the URL by "/" and extract the last two segments
IFS='/' read -r -a url_parts <<< "${repo_url}"

# Calculate the indices for the last two elements
length=${#url_parts[@]}
username="${url_parts[$((length-2))]}"
repo_name="${url_parts[$((length-1))]}"

# Remove the .git suffix if it exists
repo_name="${repo_name%.git}"

# Log repository owner
echo "Repository owner: ${username}"

# Check if the current user name is not GIT_USER_1_NAME_VALUE
if [[ "${username}" != "${GIT_USER_1_NAME_VALUE}" ]]; then
    echo "Adding a log copy to main account: ${GIT_USER_1_NAME_VALUE}"
    commit_message=$(git log -1 --pretty=%B)

    # Construct the public format URL
    public_repo_url="https://github.com/${username}/${repo_name}"

    # URL-encode the parameters
    encoded_commit_message=$(urlencode "${commit_message}")
    encoded_repo_url=$(urlencode "${public_repo_url}")

    # Make the curl request with URL-encoded parameters
    curl -X POST "${GCP_CF_ENDPOINT_VALUE}?commit_message=${encoded_commit_message}&repo_url=${encoded_repo_url}"
else
    echo "Skipping the log copy for main account: ${GIT_USER_1_NAME_VALUE}"
fi
